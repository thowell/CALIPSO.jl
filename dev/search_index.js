var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Docstrings for CALIPSO.jl interface members can be accessed through Julia's built-in documentation system or in the list below.","category":"page"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = CALIPSO","category":"page"},{"location":"api.html#Contents","page":"API Documentation","title":"Contents","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Solver","page":"API Documentation","title":"Solver","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"    Solver\n    solve!\n    initialize!\n    Options\n    empty_constraint\n    callback_inner\n    callback_outer","category":"page"},{"location":"api.html#CALIPSO.Solver","page":"API Documentation","title":"CALIPSO.Solver","text":"Solver(methods, num_variables, num_parameters, num_equality, num_cone;\n    parameters, nonnegative_indices, second_order_indices, custom, options)\n\nCALIPSO solver \n\nmethods: ProblemMethods - includes objective and constraint functions, as we as their derivatives \nnum_variables: Int - dimension of primal decision variables \nnum_parameters: Int - dimension of problem data \nnum_equality: Int - dimension of equality constraints \nnum_cone: Int - dimension of cone constraints \nparameters: Vector{Real} - problem data \nnonnegative_indices: Vector{Int} - indices of cone constraints corresponding to nonnegative orthant \nsecond_order_indices: Vector{Vector{Int}} - indices of cone constraints corresponding to second-order cones\ncustom: Any - user-provided type used for solver callbacks \noptions: Options - solver settings\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.solve!","page":"API Documentation","title":"CALIPSO.solve!","text":"solve!(solver) \n\nmethod for optimizing a Solver \n\nsolver: Solver\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.initialize!","page":"API Documentation","title":"CALIPSO.initialize!","text":"initialize!(solver, guess) \n\nmethod for initializing primal decision variables \n\nsolver: Solver \nguess: Vector{Real} - user-provided initialization for primal decision variables\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.Options","page":"API Documentation","title":"CALIPSO.Options","text":"Options \n\nCALIPSO solver settings\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.empty_constraint","page":"API Documentation","title":"CALIPSO.empty_constraint","text":"empty_constraint(x, θ)\n\nconvenience method for empty constraints \n\nx: Vector{Real} - primal decision variables \nθ: Vector{Real} - problem data\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.callback_inner","page":"API Documentation","title":"CALIPSO.callback_inner","text":"callback_inner(custom, solver)\n\nmethod called during solver's inner iterations \n\ncustom: Any - user-provided type used for solver callbacks\nsolver: Solver\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.callback_outer","page":"API Documentation","title":"CALIPSO.callback_outer","text":"callback_outer(custom, solver)\n\nmethod called during solver's outer updates \n\ncustom: Any - user-provided type used for solver callbacks\nsolver: Solver\n\n\n\n\n\n","category":"function"},{"location":"api.html#Trajectory-Optimization","page":"API Documentation","title":"Trajectory Optimization","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"    Cost\n    Constraint\n    Constraints\n    Dynamics\n    initialize_states!\n    initialize_actions!\n    get_trajectory\n    linear_interpolation","category":"page"},{"location":"api.html#CALIPSO.Cost","page":"API Documentation","title":"CALIPSO.Cost","text":"Cost(cost, num_state, num_action;\n    num_parameter, checkbounds, constraint_tensor)\n\nstage-cost type \n\ncost: Function \nnum_state: Int - dimension of state \nnum_action: Int - dimension of action \nnum_parameter: Int - dimension of problem data \ncheckbounds: Bool - flag for checking @inbounds for codegen methods \nconstraint_tensor: Bool - flag for generating second-derivative methods\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.Constraint","page":"API Documentation","title":"CALIPSO.Constraint","text":"Constraint(constraint, num_state, num_action;\n    num_parameter, checkbounds, constraint_tensor)\n\nconstraint type \n\nconstraint: Function \nnum_state: Int - dimension of state \nnum_action: Int - dimension of action \nnum_parameter: Int - dimension of problem data \ncheckbounds: Bool - flag for checking @inbounds for codegen methods \nconstraint_tensor: Bool - flag for generating second-derivative methods\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.Constraints","page":"API Documentation","title":"CALIPSO.Constraints","text":"Constraints \n\nvector of Constraint types\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.Dynamics","page":"API Documentation","title":"CALIPSO.Dynamics","text":"Dynamics(dynamics, num_next_state, num_state, num_action;\n    num_parameter, checkbounds, constraint_tensor)\n\ndynamics type \n\ndynamics: Function \nnum_next_state: Int - dimension of next state\nnum_state: Int - dimension of current state \nnum_action: Int - dimension of current action \nnum_parameter: Int - dimension of problem data \ncheckbounds: Bool - flag for checking @inbounds for codegen methods \nconstraint_tensor: Bool - flag for generating second-derivative methods\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALIPSO.initialize_states!","page":"API Documentation","title":"CALIPSO.initialize_states!","text":"initialize_states!(solver::Solver, states)\n\nmethod for initialized primal variables with state trajectory \n\nsolver: Solver \nstates: Vector{Vector{Real}} - trajectory of states\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.initialize_actions!","page":"API Documentation","title":"CALIPSO.initialize_actions!","text":"initialize_actions!(solver::Solver, actions)\n\nmethod for initialized primal variables with action trajectory \n\nsolver: Solver \nactions: Vector{Vector{Real}} - trajectory of actions\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.get_trajectory","page":"API Documentation","title":"CALIPSO.get_trajectory","text":"get_trajectory(solver)\n\nmethod for returning state and action trajectories from solver \n\nsolver: Solver\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALIPSO.linear_interpolation","page":"API Documentation","title":"CALIPSO.linear_interpolation","text":"linear_interpolation(initial_state, final_state, horizon)\n\nmethod for generating a linear interpolating trajectory \n\ninitial_state: Vector{Real} - first state \nfinal_state: Vector{Real} - last state \nhorizon: Int - length of trajectory\n\n\n\n\n\n","category":"function"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Contributions are always welcome!","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"If you want to contribute features, bug fixes, etc, please take a look at our Code Style Guide below\nPlease report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use CALIPSO. Please let us know via email to: thowell@stanford.edu","category":"page"},{"location":"contributing.html#Potentially-Useful-Contributions","page":"Contributing","title":"Potentially Useful Contributions","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Here are a list of current to-do's that would make awesome contributions:","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"support for sparse FiniteDiff, ForwardDiff derivatives\nsupport for additional linear-system solvers like: Pardiso, HSL, or Krylov\nintegration with ChainRules\nprecompilation\nPython + JAX/Torch wrapper","category":"page"},{"location":"contributing.html#Code-Style-Guide","page":"Contributing","title":"Code Style Guide","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The code in this repository follows the naming and style conventions of Julia Base with a few modifications. This style guide is heavily \"inspired\" by the guides of John Myles White, JuMP, and COSMO","category":"page"},{"location":"contributing.html#Formatting","page":"Contributing","title":"Formatting","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use one tab when indenting a new block (except module)\nUse spaces between operators, except for ^, ', and :\nUse single space after commas and semicolons\nDon't use spaces around parentheses, or braces","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: f(x,y) = [5*sin(x+y);y'] Good: f(x, y) = [5 * sin(x + y); y']","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use spacing with keyword arguments","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: foo(x::Float; y::Integer = 1) Good: foo(x::Float; y::Integer=1)","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Don't parenthesize conditions","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: if (a == b) Good: if a == b","category":"page"},{"location":"contributing.html#Naming","page":"Contributing","title":"Naming","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Modules and Type names use capitilization and camel case, e.g. module LinearAlgebra, struct ConvexSets.\nFunctions are lowercase and use underscores to seperate words, e.g. has_key(x), is_valid(y).\nNormal variables are lowercase and use underscores like functions, e.g. convex_set\nConstants are uppercase, e.g. const MY_CONSTANT\nAlways append ! to names of functions that modify their arguments.\nFunction arguments that are mutated come first. Otherwise follow the rules layed out in Julia Base Argument ordering\nFiles are named like functions, e.g. my_new_file.jl","category":"page"},{"location":"contributing.html#Syntax","page":"Contributing","title":"Syntax","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use 1.0 instead of 1.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Examples from our paper are generated upon installation of the package and can be found here.","category":"page"},{"location":"examples.html#Contact-implicit-trajectory-optimization","page":"Examples","title":"Contact-implicit trajectory optimization","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For a system modeled with Q contact points, the smooth dynamics, as well as impact and friction, are modeled at each timestep t with the following constraints:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginalign*\n\tf_t(q_t-1 q_t q_t+1) + B_t(q_t) u_t + C_t(q_t)^T lambda_t = 0 \n \tphi(q_t+1) geq 0 \n \tgamma_t circ phi_t(q_t+1) = 0 \n \tbeta_t^(i) circ eta_t^(i) = 0 quad i = 1 dots Q \n \tv^(i)(q_t q_t+1) - eta_t_(23)^(i) = 0 quad i = 1 dots Q \n \tbeta_t_(1)^(i) - mu^(i) gamma_t^(i) = 0 quad i = 1 dots Q \n \tgamma_t phi_t(q_t+1)  geq 0 \n \tbeta_t^(i) eta_t^(i) in mathcalQ^3 quad i = 1 dots Q\nendalign*","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"with configurations q_t in mathbfR^n_q, smooth discrete-time dynamics f_t  mathbfR^n_q times mathbfR^n_q rightarrow mathbfR^n_q, input Jacobian B_t  mathbfR^n_q rightarrow mathbfR^n_q times m, contact Jacobian C_t  mathbfR^n_q rightarrow mathbfR^3P times n_q, contact impulses lambda_t in mathbfR^3Q, signed distance phi_t  mathbfR^n_q rightarrow mathbfR^P, impact impulses gamma_t in mathbfR^P, friction primals and duals beta_t eta_t in mathbfR^3, contact-point tangential velocity v  mathbfR^n_q times mathbfR^n_q rightarrow mathbfR^2, and friction coefficient mu in mathbfR_+, where lambda = (beta_(23) gamma). For additional details, see: [1] [2]","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We utilize this formulation to optimize motions for: ","category":"page"},{"location":"examples.html#ball-in-cup","page":"Examples","title":"ball-in-cup","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/ball_in_cup.gif\" width=\"150\"/>","category":"page"},{"location":"examples.html#bunny-hop","page":"Examples","title":"bunny hop","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/atlas_bunnyhop.gif\" width=\"400\"/>","category":"page"},{"location":"examples.html#quadruped-gait","page":"Examples","title":"quadruped gait","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/quadruped_gait.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html#drifting","page":"Examples","title":"drifting","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/cyberdrift.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html#State-triggered-constraints","page":"Examples","title":"State-triggered constraints","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"A trigger condition GammamathbfR^n rightarrow mathbfR encodes the logic: Gamma(x)  0 implies h(x) geq 0, that a constraint is enforced only when the trigger is satisfied. Such state-triggered constraints are utilized within various aerospace applications and commonly utilize a non-smooth formulation (left):","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginequation*\n    textmin(0 -Gamma(x)) cdot h(x) leq 0\n    quad\n    rightarrow \n    quad\n    beginalign*\n\t\tGamma_+ - Gamma_- = Gamma(x) \n        h_+ - h_- = h(x) \n        Gamma_+ cdot h_- = 0 \n        Gamma_+ Gamma_- h_+ h_-  geq 0\n\tendalign*\nendequation*","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"With CALIPSO, we employ an equivalent complementarity formulation (right) in order to land a rocket while avoiding keep-out zones.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/figures/stc_rocket.jpg\" width=\"250\"/>","category":"page"},{"location":"examples.html#Model-predictive-control-auto-tuning","page":"Examples","title":"Model-predictive control auto-tuning","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"A feedback policy is utilized to control underactuated robotic systems by tracking a reference barX_1T barU_1T-1. The model-predictive control policy,","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginalign*\n\t\tpi(hatX theta) = U^*_1 = undersetX_1H phantom U_1H-1textarg min   (X_H - barX_t + H)^T P(theta) (X_H - barX_t + H) + sum limits_tau = 1^H-1 (X_tau - barX_t + tau)^T Q(theta) (X_tau - barX_t + tau) + (U_tau - barU_t + tau)^T R(theta) (U_tau - barU_t + tau) \n\t\ttextsubject to   F_tau(X_tau U_tau) = X_tau+1 quad tau = 1dotsH-1 \n\t\t X_1 = hatX phantom _t+1 \nendalign*","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"computes controls by solving an optimization problem with horizon H using CALIPSO and applying the first control to the system. Auto-tuning is performed to modify the weights in the policy's objective using gradient descent to minimize a metric that aims to minimize the difference between forward rollouts of the actual system and the reference trajectory.","category":"page"},{"location":"examples.html#cart-pole","page":"Examples","title":"cart-pole","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/cartpole_openloop.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(open-loop)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/cartpole_untuned.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(untuned)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/cartpole_tuned.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(MPC tuned)","category":"page"},{"location":"examples.html#acrobot","page":"Examples","title":"acrobot","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/acrobot_openloop.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(open-loop)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/acrobot_untuned.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(untuned)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"./assets/animations/acrobot_tuned.gif\" width=\"250\"/>","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(MPC tuned)","category":"page"},{"location":"solver.html#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"CALIPSO is a solver for non-convex optimization problems designed for robotics applications with conic and complementarity constraints. Additionally, solutions are differentiable with respect to problem data provided to the solver.","category":"page"},{"location":"solver.html#Standard-form","page":"Solver","title":"Standard form","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Problems:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"beginalign*\nundersetxtextminimize  quad c(x theta) \ntextsubject to  quad  g(x theta) = 0 \n                   quad  h(x theta) in mathcalK \nendalign*","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"with ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"x in mathbfR^n: decision variables  \ntheta in mathbfR^d: problem data  ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"are optimized for ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"c  mathbfR^n times mathbfR^d rightarrow mathbfR: objective \ng  mathbfR^n times mathbfR^d rightarrow mathbfR^m: equality constraints\nh  mathbfR^n times mathbfR^d rightarrow mathbfR^p:  cone constraints ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"The cone,","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"mathcalK = mathbfR_++^q times Q_l_1^(1) times dots times Q_l_j^(j)","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"is the Cartesian product of the q-dimensional nonnegative orthant and j second-order cones, each of dimension l_i.","category":"page"},{"location":"solver.html#Non-convex-problem-example","page":"Solver","title":"Non-convex problem example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example, we formulate and solve the Wächter problem that motivated many of the algorithms and heuristics developed for Ipopt:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO\n\n# problem\nobjective(x) = x[1]\nequality(x) = [x[1]^2 - x[2] - 1.0; x[1] - x[3] - 0.5]\ncone(x) = x[2:3]\n\n# variables \nnum_variables = 3\n\n# solver\nsolver = Solver(objective, equality, cone, num_variables);\n\n# initialize\nx0 = [-2.0, 3.0, 1.0]\ninitialize!(solver, x0)\n\n# solve \nsolve!(solver)\n\n# solution \nsolver.solution.variables # x* = [1.0, 0.0, 0.5]","category":"page"},{"location":"solver.html#Trajectory-optimization","page":"Solver","title":"Trajectory optimization","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Deterministic Markov Decision Processes,","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"beginalign*\n\t\tundersetX_1T phantom U_1T-1textminimize   C_T(X_T theta_T) + sum limits_t = 1^T-1 C_t(X_t U_t theta_t) \n\t\ttextsubject to   F_t(X_t U_t theta_t) = X_t+1 quad t = 1dotsT-1 \n\t\t E_t(X_t U_t theta_t) = 0 phantom _t+1 quad t = 1 dots T \n\t\t H_t(X_t U_t theta_t) in mathcalK_t phantomX quad t = 1 dots T\nendalign*","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"with ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"X_t in mathbfR^n_t: state\nU_t in mathbfR^m_t: action\ntheta_t in mathbfR^d_t: problem data ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"and ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"C_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR: stage cost\nF_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^n_t+1: discrete-time dynamics \nE_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^e_t: equality constraint\nH_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^h_t: cone constraints ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"are automatically transcribed and optimized with CALIPSO.","category":"page"},{"location":"solver.html#Pendulum-swing-up-example","page":"Solver","title":"Pendulum swing-up example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example, we optimize state and action trajectories in order to perform a swing-up with a pendulum system:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO \nusing LinearAlgebra \n\n# horizon \nhorizon = 11 \n\n# dimensions \nnum_states = [2 for t = 1:horizon]\nnum_actions = [1 for t = 1:horizon-1] \n\n# dynamics\nfunction pendulum_continuous(x, u)\n   mass = 1.0\n   length_com = 0.5\n   gravity = 9.81\n   damping = 0.1\n\n   [\n      x[2],\n      (u[1] / ((mass * length_com * length_com))\n            - gravity * sin(x[1]) / length_com\n            - damping * x[2] / (mass * length_com * length_com))\n   ]\nend\n\nfunction pendulum_discrete(y, x, u)\n   h = 0.05 # timestep \n   y - (x + h * pendulum_continuous(0.5 * (x + y), u))\nend\n\ndynamics = [pendulum_discrete for t = 1:horizon-1] \n\n# states\nstate_initial = [0.0; 0.0] \nstate_goal = [π; 0.0] \n\n# objective \nobjective = [\n   [(x, u) -> 0.1 * dot(x[1:2], x[1:2]) + 0.1 * dot(u, u) for t = 1:horizon-1]..., \n   (x, u) -> 0.1 * dot(x[1:2], x[1:2]),\n];\n\n# constraints \nequality = [\n      (x, u) -> x - state_initial, \n      [empty_constraint for t = 2:horizon-1]..., \n      (x, u) -> x - state_goal,\n];\n\n# solver \nsolver = Solver(objective, dynamics, num_states, num_actions; \n   equality=equality);\n\n# initialize\nstate_guess = linear_interpolation(state_initial, state_goal, horizon)\naction_guess = [1.0 * randn(num_actions[t]) for t = 1:horizon-1]\ninitialize_states!(solver, state_guess) \ninitialize_actions!(solver, action_guess)\n\n# solve \nsolve!(solver)\n\n# solution\nstate_solution, action_solution = get_trajectory(solver);","category":"page"},{"location":"solver.html#Solution-gradients","page":"Solver","title":"Solution gradients","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"The solutions returned by CALIPSO are differentiable with respect to problem data provided to the solver. ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"    fracpartial wpartial theta = -Big(fracpartial Rpartial wBig)^-1 fracpartial Rpartial theta","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Sensitivities are efficiently computing via the implicit-function theorem. This functionality can be utilized by setting the solver option: differentiate = true.","category":"page"},{"location":"solver.html#Differentiable-trajectory-optimization-example","page":"Solver","title":"Differentiable trajectory-optimization example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example we demonstrate how problem data can be provided to the solver in order to get gradients of the solution with respect to these values. For more advanced usage, see our auto-tuning examples.","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO\nusing LinearAlgebra\n\n# horizon \nhorizon = 5\n\n# dimensions \nnum_states = [2 for t = 1:horizon]\nnum_actions = [1 for t = 1:horizon-1] \n\n# dynamics\nfunction double_integrator(y, x, u, w)\n\tA = reshape(w[1:4], 2, 2) \n\tB = w[4 .+ (1:2)] \n\n\treturn y - (A * x + B * u[1])\nend\n\n# model\ndynamics = [double_integrator for t = 1:horizon-1]\n\n# parameters\nstate_initial = [0.0; 0.0] \nstate_goal = [1.0; 0.0] \n\nA = [1.0 1.0; 0.0 1.0]\nB = [0.0; 1.0]\nQt = [1.0 0.0; 0.0 1.0] \nRt = [0.1]\nQT = [10.0 0.0; 0.0 10.0] \nθ1 = [vec(A); B; diag(Qt); Rt; state_initial]\nθt = [vec(A); B; diag(Qt); Rt]  \nθT = [diag(QT); state_goal] \nparameters = [θ1, [θt for t = 2:horizon-1]..., θT]\n\n# objective \nfunction obj1(x, u, w) \n\tQ1 = Diagonal(w[6 .+ (1:2)])\n\tR1 = w[8 + 1]\n\treturn 0.5 * transpose(x) * Q1 * x + 0.5 * R1 * transpose(u) * u\nend\n\nfunction objt(x, u, w) \n\tQt = Diagonal(w[6 .+ (1:2)])\n\tRt = w[8 + 1]\n\treturn 0.5 * transpose(x) * Qt * x + 0.5 * Rt * transpose(u) * u\nend\n\nfunction objT(x, u, w) \n\tQT = Diagonal(w[0 .+ (1:2)])\n\treturn 0.5 * transpose(x) * QT * x\nend\n\nobjective = [\n\t\t\t\tobj1,\n\t\t\t\t[objt for t = 2:horizon-1]...,\n\t\t\t\tobjT,\n]\n\n# constraints \nequality = [\n\t\t(x, u, w) -> 1 * (x - w[9 .+ (1:2)]),\n\t\t[empty_constraint for t = 2:horizon-1]...,\n\t\t(x, u, w) -> 1 * (x - w[2 .+ (1:2)]),\n]\n\n# options \noptions = Options(\n\t\tresidual_tolerance=1.0e-12, \n\t\tequality_tolerance=1.0e-8,\n\t\tcomplementarity_tolerance=1.0e-8,\n\t\tdifferentiate=true) # <--- setting to get solution gradients\n\n# solver \nsolver = Solver(objective, dynamics, num_states, num_actions;\n\tparameters=parameters,\n\tequality=equality,\n\toptions=options);\n\n# initialize\nstate_guess = linear_interpolation(state_initial, state_goal, horizon)\naction_guess = [1.0 * randn(num_actions[t]) for t = 1:horizon-1]\ninitialize_states!(solver, state_guess) \ninitialize_actions!(solver, action_guess)\n\n# solve \nsolve!(solver)\n\n# solution\nstate_solution, action_solution = get_trajectory(solver);","category":"page"},{"location":"index.html#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"CALIPSO is a differentiable solver for trajectory optimization with conic and complementarity constraints. The solver is written in pure Julia in order to be both performant and easy to use.","category":"page"},{"location":"index.html#Features","page":"Get Started","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Differentiable: Solutions are efficiently differentiable with respect to problem data provided to the solver\nTrajectory Optimization: Problems formulated as deterministic Markov Decision Processes are automatically transcribed for the solver\nComplementarity Constraints: Complementarity constraints can be provided to the solver without reformulation\nSecond-Order-Cone Constraints: Cone constraints are natively supported in the non-convex problem setting\nCodegen for Derivatives: User-provided functions (e.g., objective, constraints) are symbolically differentiated and fast code is autogenerated using Symbolics.jl\nOpen Source: Code is available on GitHub and distributed under the MIT Licence","category":"page"},{"location":"index.html#Installation","page":"Get Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"CALIPSO can be installed using the Julia package manager for Julia v1.7 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add CALIPSO","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If you want to install the latest version from Github run:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add CALIPSO#main","category":"page"},{"location":"index.html#Citation","page":"Get Started","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If this project is useful for your work please consider:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Citing the relevant paper\nLeaving a star on the GitHub repository","category":"page"},{"location":"index.html#Licence","page":"Get Started","title":"Licence","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"CALIPSO is licensed under the MIT License. For more details click here.","category":"page"},{"location":"citing.html#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing.html","page":"Citing","title":"Citing","text":"If you find CALIPSO useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"@article{howell2022calipso,\n\ttitle={{CALIPSO}: {A} {Differentiable} {Solver} for {Trajectory} {Optimization} with {Conic} and {Complementarity} {Constraints},\n\tauthor={Howell, Taylor A. and Tracy, Kevin and Le Cleac'h, Simon and Manchester, Zachary},\n\tyear={2022}\n}","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"A preprint can be downloaded from arXiv.","category":"page"}]
}
